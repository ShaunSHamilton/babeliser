{"mappings":"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","sources":["src/index.ts"],"sourcesContent":["import { parse, ParserOptions } from \"@babel/parser\";\nimport generate, { GeneratorOptions } from \"@babel/generator\";\nimport {\n  ArrowFunctionExpression,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  ImportDeclaration,\n  is,\n  Node,\n  VariableDeclaration,\n  Statement,\n} from \"@babel/types\";\n\ntype BabeliserOptions = { maxScopeDepth: number };\ntype Scope = Array<string>;\ntype ScopedStatement = Statement & { scope: Scope };\n\nexport class Babeliser {\n  public parsedCode: ReturnType<typeof parse>;\n  private maxScopeDepth = 4;\n  public codeString: string;\n  constructor(\n    codeString: string,\n    options?: Partial<ParserOptions & BabeliserOptions>\n  ) {\n    this.parsedCode = parse(codeString, {\n      sourceType: \"module\",\n      ...options,\n    });\n    if (options?.maxScopeDepth) {\n      this.maxScopeDepth = options.maxScopeDepth;\n    }\n    this.codeString = codeString;\n  }\n  public getArrowFunctionExpressions() {\n    const arrowFunctionDeclarations =\n      this._recurseBodiesForType<ArrowFunctionExpression>(\n        \"ArrowFunctionExpression\"\n      );\n    return arrowFunctionDeclarations;\n  }\n  public getExpressionStatements() {\n    const expressionStatements =\n      this._recurseBodiesForType<ExpressionStatement>(\"ExpressionStatement\");\n    return expressionStatements;\n  }\n  public getFunctionDeclarations() {\n    const functionDeclarations =\n      this._recurseBodiesForType<FunctionDeclaration>(\"FunctionDeclaration\");\n    return functionDeclarations;\n  }\n  public getImportDeclarations() {\n    const expressionStatements =\n      this._recurseBodiesForType<ImportDeclaration>(\"ImportDeclaration\");\n    return expressionStatements;\n  }\n  public getType<T>(type: string) {\n    return this._recurseBodiesForType<T>(type);\n  }\n  public getVariableDeclarations() {\n    const variableDeclarations =\n      this._recurseBodiesForType<VariableDeclaration>(\"VariableDeclaration\");\n    return variableDeclarations;\n  }\n\n  public getExpressionStatement(\n    name: string,\n    scope: Scope = [\"global\"]\n  ): (ExpressionStatement & { scope: Scope }) | undefined {\n    const expressionStatements = this.getExpressionStatements().filter((a) =>\n      this._isInScope(a.scope, scope)\n    );\n    const expressionStatement = expressionStatements.find((e) => {\n      const expression = e.expression;\n      if (is(\"CallExpression\", expression)) {\n        if (name.includes(\".\")) {\n          const [objectName, methodName] = name.split(\".\");\n          const memberExpression = expression.callee;\n          if (is(\"MemberExpression\", memberExpression)) {\n            const object = memberExpression.object;\n            const property = memberExpression.property;\n            if (is(\"Identifier\", object) && is(\"Identifier\", property)) {\n              return object.name === objectName && property.name === methodName;\n            }\n          }\n        }\n        const identifier = expression.callee;\n        if (is(\"Identifier\", identifier) && identifier.name === name) {\n          return true;\n        }\n      }\n      if (is(\"AwaitExpression\", expression)) {\n        const callExpression = expression.argument;\n        if (is(\"CallExpression\", callExpression)) {\n          const identifier = callExpression.callee;\n          if (is(\"Identifier\", identifier)) {\n            return identifier.name === name;\n          }\n        }\n      }\n      return false;\n    });\n    return expressionStatement;\n  }\n\n  public generateCode(ast: Node, options?: GeneratorOptions) {\n    return generate.default(ast, options).code;\n  }\n\n  public getLineAndColumnFromIndex(index: number) {\n    const linesBeforeIndex = this.codeString.slice(0, index).split(\"\\n\");\n    const line = linesBeforeIndex.length;\n    const column = linesBeforeIndex.pop()?.length;\n    return { line, column };\n  }\n\n  private _isInScope(scope: Scope, targetScope: Scope = [\"global\"]): boolean {\n    if (targetScope.length === 1 && targetScope[0] === \"global\") {\n      return true;\n    }\n    if (scope.length < targetScope.length) {\n      return false;\n    }\n    const scopeString = scope.join(\".\");\n    const targetScopeString = targetScope.join(\".\");\n    return scopeString.includes(targetScopeString);\n  }\n\n  private _recurseBodiesForType<T>(type: string): Array<T & { scope: Scope }> {\n    const body = this.parsedCode.program.body;\n    const types = [];\n    for (const statement of body) {\n      const a = this._recurse(statement, (a) => a?.type === type, [\"global\"]);\n      if (a?.length) {\n        types.push(...a);\n      }\n    }\n    return types;\n  }\n\n  private _recurse(\n    // this is kind of a hack, since we're mutating val. It needs to be able to\n    // have a scope parameter, though it's never passed in with one.\n    val: Statement & { scope?: Scope },\n    isTargetType: (...args: any) => boolean,\n    scope: Array<string>\n  ): ScopedStatement[] {\n    if (scope.length >= this.maxScopeDepth) {\n      return;\n    }\n    const matches = [];\n    if (val && typeof val === \"object\") {\n      if (!Array.isArray(val)) {\n        val.scope = scope;\n      }\n      if (isTargetType(val)) {\n        matches.push(val);\n      }\n\n      let currentScope = [...scope];\n      const nearestIdentifier: undefined | Identifier = Object.values(val).find(\n        (v) => v?.type === \"Identifier\"\n      );\n      if (nearestIdentifier) {\n        currentScope.push(nearestIdentifier.name);\n      }\n\n      for (const v of Object.values(val)) {\n        const mat = this._recurse(v, isTargetType, currentScope);\n        const toPush = mat?.filter(Boolean).flat();\n        if (toPush?.length) {\n          matches.push(...toPush.flat());\n        }\n      }\n    }\n    return matches;\n  }\n}\n"],"names":[],"version":3,"file":"module.js.map"}