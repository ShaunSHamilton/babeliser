{"mappings":";;;AAcA,wBAAwB;IAAE,aAAa,EAAE,MAAM,CAAA;CAAE,CAAC;AAClD,aAAa,KAAK,CAAC,MAAM,CAAC,CAAC;AAG3B;IACS,UAAU,EAAE,UAAU,CAAC,YAAY,CAAC,CAAC;IAErC,UAAU,EAAE,MAAM,CAAC;gBAExB,UAAU,EAAE,MAAM,EAClB,OAAO,CAAC,EAAE,OAAO,CAAC,aAAa,GAAG,gBAAgB,CAAC;IAW9C,2BAA2B;;;IAO3B,uBAAuB;;;IAKvB,uBAAuB;;;IAKvB,qBAAqB;;;IAKrB,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM;;;IAGvB,uBAAuB;;;IAMvB,sBAAsB,CAC3B,IAAI,EAAE,MAAM,EACZ,KAAK,GAAE,KAAkB,GACxB,CAAC,mBAAmB,GAAG;QAAE,KAAK,EAAE,KAAK,CAAA;KAAE,CAAC,GAAG,SAAS;IAqChD,YAAY,CAAC,GAAG,EAAE,IAAI,EAAE,OAAO,CAAC,EAAE,gBAAgB;IAIlD,yBAAyB,CAAC,KAAK,EAAE,MAAM;;;;CAoE/C","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { parse, ParserOptions } from \"@babel/parser\";\nimport generate, { GeneratorOptions } from \"@babel/generator\";\nimport {\n  ArrowFunctionExpression,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  ImportDeclaration,\n  is,\n  Node,\n  VariableDeclaration,\n  Statement,\n} from \"@babel/types\";\n\ntype BabeliserOptions = { maxScopeDepth: number };\ntype Scope = Array<string>;\ntype ScopedStatement = Statement & { scope: Scope };\n\nexport class Babeliser {\n  public parsedCode: ReturnType<typeof parse>;\n  private maxScopeDepth = 4;\n  public codeString: string;\n  constructor(\n    codeString: string,\n    options?: Partial<ParserOptions & BabeliserOptions>\n  ) {\n    this.parsedCode = parse(codeString, {\n      sourceType: \"module\",\n      ...options,\n    });\n    if (options?.maxScopeDepth) {\n      this.maxScopeDepth = options.maxScopeDepth;\n    }\n    this.codeString = codeString;\n  }\n  public getArrowFunctionExpressions() {\n    const arrowFunctionDeclarations =\n      this._recurseBodiesForType<ArrowFunctionExpression>(\n        \"ArrowFunctionExpression\"\n      );\n    return arrowFunctionDeclarations;\n  }\n  public getExpressionStatements() {\n    const expressionStatements =\n      this._recurseBodiesForType<ExpressionStatement>(\"ExpressionStatement\");\n    return expressionStatements;\n  }\n  public getFunctionDeclarations() {\n    const functionDeclarations =\n      this._recurseBodiesForType<FunctionDeclaration>(\"FunctionDeclaration\");\n    return functionDeclarations;\n  }\n  public getImportDeclarations() {\n    const expressionStatements =\n      this._recurseBodiesForType<ImportDeclaration>(\"ImportDeclaration\");\n    return expressionStatements;\n  }\n  public getType<T>(type: string) {\n    return this._recurseBodiesForType<T>(type);\n  }\n  public getVariableDeclarations() {\n    const variableDeclarations =\n      this._recurseBodiesForType<VariableDeclaration>(\"VariableDeclaration\");\n    return variableDeclarations;\n  }\n\n  public getExpressionStatement(\n    name: string,\n    scope: Scope = [\"global\"]\n  ): (ExpressionStatement & { scope: Scope }) | undefined {\n    const expressionStatements = this.getExpressionStatements().filter((a) =>\n      this._isInScope(a.scope, scope)\n    );\n    const expressionStatement = expressionStatements.find((e) => {\n      const expression = e.expression;\n      if (is(\"CallExpression\", expression)) {\n        if (name.includes(\".\")) {\n          const [objectName, methodName] = name.split(\".\");\n          const memberExpression = expression.callee;\n          if (is(\"MemberExpression\", memberExpression)) {\n            const object = memberExpression.object;\n            const property = memberExpression.property;\n            if (is(\"Identifier\", object) && is(\"Identifier\", property)) {\n              return object.name === objectName && property.name === methodName;\n            }\n          }\n        }\n        const identifier = expression.callee;\n        if (is(\"Identifier\", identifier) && identifier.name === name) {\n          return true;\n        }\n      }\n      if (is(\"AwaitExpression\", expression)) {\n        const callExpression = expression.argument;\n        if (is(\"CallExpression\", callExpression)) {\n          const identifier = callExpression.callee;\n          if (is(\"Identifier\", identifier)) {\n            return identifier.name === name;\n          }\n        }\n      }\n      return false;\n    });\n    return expressionStatement;\n  }\n\n  public generateCode(ast: Node, options?: GeneratorOptions) {\n    return generate.default(ast, options).code;\n  }\n\n  public getLineAndColumnFromIndex(index: number) {\n    const linesBeforeIndex = this.codeString.slice(0, index).split(\"\\n\");\n    const line = linesBeforeIndex.length;\n    const column = linesBeforeIndex.pop()?.length;\n    return { line, column };\n  }\n\n  private _isInScope(scope: Scope, targetScope: Scope = [\"global\"]): boolean {\n    if (targetScope.length === 1 && targetScope[0] === \"global\") {\n      return true;\n    }\n    if (scope.length < targetScope.length) {\n      return false;\n    }\n    const scopeString = scope.join(\".\");\n    const targetScopeString = targetScope.join(\".\");\n    return scopeString.includes(targetScopeString);\n  }\n\n  private _recurseBodiesForType<T>(type: string): Array<T & { scope: Scope }> {\n    const body = this.parsedCode.program.body;\n    const types = [];\n    for (const statement of body) {\n      const a = this._recurse(statement, (a) => a?.type === type, [\"global\"]);\n      if (a?.length) {\n        types.push(...a);\n      }\n    }\n    return types;\n  }\n\n  private _recurse(\n    // this is kind of a hack, since we're mutating val. It needs to be able to\n    // have a scope parameter, though it's never passed in with one.\n    val: Statement & { scope?: Scope },\n    isTargetType: (...args: any) => boolean,\n    scope: Array<string>\n  ): ScopedStatement[] {\n    if (scope.length >= this.maxScopeDepth) {\n      return;\n    }\n    const matches = [];\n    if (val && typeof val === \"object\") {\n      if (!Array.isArray(val)) {\n        val.scope = scope;\n      }\n      if (isTargetType(val)) {\n        matches.push(val);\n      }\n\n      let currentScope = [...scope];\n      const nearestIdentifier: undefined | Identifier = Object.values(val).find(\n        (v) => v?.type === \"Identifier\"\n      );\n      if (nearestIdentifier) {\n        currentScope.push(nearestIdentifier.name);\n      }\n\n      for (const v of Object.values(val)) {\n        const mat = this._recurse(v, isTargetType, currentScope);\n        const toPush = mat?.filter(Boolean).flat();\n        if (toPush?.length) {\n          matches.push(...toPush.flat());\n        }\n      }\n    }\n    return matches;\n  }\n}\n"],"names":[],"version":3,"file":"index.d.ts.map"}