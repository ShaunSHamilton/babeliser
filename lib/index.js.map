{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "import { parse, ParserOptions } from \"@babel/parser\";\nimport generate, { GeneratorOptions } from \"@babel/generator\";\nimport {\n  ArrowFunctionExpression,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  ImportDeclaration,\n  is,\n  Node,\n  VariableDeclaration,\n  Statement,\n} from \"@babel/types\";\n\ntype BabeliserOptions = { maxScopeDepth: number };\ntype Scope = Array<string>;\ntype ScopedStatement = Statement & { scope: Scope };\n\nexport class Babeliser {\n  public parsedCode: ReturnType<typeof parse>;\n  private maxScopeDepth = 4;\n  public codeString: string;\n  constructor(\n    codeString: string,\n    options?: Partial<ParserOptions & BabeliserOptions>\n  ) {\n    this.parsedCode = parse(codeString, {\n      sourceType: \"module\",\n      ...options,\n    });\n    if (options?.maxScopeDepth) {\n      this.maxScopeDepth = options.maxScopeDepth;\n    }\n    this.codeString = codeString;\n  }\n  public getArrowFunctionExpressions() {\n    const arrowFunctionDeclarations =\n      this._recurseBodiesForType<ArrowFunctionExpression>(\n        \"ArrowFunctionExpression\"\n      );\n    return arrowFunctionDeclarations;\n  }\n  public getExpressionStatements() {\n    const expressionStatements =\n      this._recurseBodiesForType<ExpressionStatement>(\"ExpressionStatement\");\n    return expressionStatements;\n  }\n  public getFunctionDeclarations() {\n    const functionDeclarations =\n      this._recurseBodiesForType<FunctionDeclaration>(\"FunctionDeclaration\");\n    return functionDeclarations;\n  }\n  public getImportDeclarations() {\n    const expressionStatements =\n      this._recurseBodiesForType<ImportDeclaration>(\"ImportDeclaration\");\n    return expressionStatements;\n  }\n  public getType<T>(type: string) {\n    return this._recurseBodiesForType<T>(type);\n  }\n  public getVariableDeclarations() {\n    const variableDeclarations =\n      this._recurseBodiesForType<VariableDeclaration>(\"VariableDeclaration\");\n    return variableDeclarations;\n  }\n\n  public getExpressionStatement(\n    name: string,\n    scope: Scope = [\"global\"]\n  ): (ExpressionStatement & { scope: Scope }) | undefined {\n    const expressionStatements = this.getExpressionStatements().filter((a) =>\n      this._isInScope(a.scope, scope)\n    );\n    const expressionStatement = expressionStatements.find((e) => {\n      const expression = e.expression;\n      if (is(\"CallExpression\", expression)) {\n        if (name.includes(\".\")) {\n          const [objectName, methodName] = name.split(\".\");\n          const memberExpression = expression.callee;\n          if (is(\"MemberExpression\", memberExpression)) {\n            const object = memberExpression.object;\n            const property = memberExpression.property;\n            if (is(\"Identifier\", object) && is(\"Identifier\", property)) {\n              return object.name === objectName && property.name === methodName;\n            }\n          }\n        }\n        const identifier = expression.callee;\n        if (is(\"Identifier\", identifier) && identifier.name === name) {\n          return true;\n        }\n      }\n      if (is(\"AwaitExpression\", expression)) {\n        const callExpression = expression.argument;\n        if (is(\"CallExpression\", callExpression)) {\n          const identifier = callExpression.callee;\n          if (is(\"Identifier\", identifier)) {\n            return identifier.name === name;\n          }\n        }\n      }\n      return false;\n    });\n    return expressionStatement;\n  }\n\n  public generateCode(ast: Node, options?: GeneratorOptions) {\n    return generate(ast, options).code;\n  }\n\n  public getLineAndColumnFromIndex(index: number) {\n    const linesBeforeIndex = this.codeString.slice(0, index).split(\"\\n\");\n    const line = linesBeforeIndex.length;\n    const column = linesBeforeIndex.pop()?.length;\n    return { line, column };\n  }\n\n  private _isInScope(scope: Scope, targetScope: Scope = [\"global\"]): boolean {\n    if (targetScope.length === 1 && targetScope[0] === \"global\") {\n      return true;\n    }\n    if (scope.length < targetScope.length) {\n      return false;\n    }\n    const scopeString = scope.join(\".\");\n    const targetScopeString = targetScope.join(\".\");\n    return scopeString.includes(targetScopeString);\n  }\n\n  private _recurseBodiesForType<T>(type: string): Array<T & { scope: Scope }> {\n    const body = this.parsedCode.program.body;\n    const types = [];\n    for (const statement of body) {\n      const a = this._recurse(statement, (a) => a?.type === type, [\"global\"]);\n      if (a?.length) {\n        types.push(...a);\n      }\n    }\n    // @ts-ignore There is no easy way to type this without writing out constraining to the 40+ types\n    return types;\n  }\n\n  private _recurse(\n    // this is kind of a hack, since we're mutating val. It needs to be able to\n    // have a scope parameter, though it's never passed in with one.\n    val: Statement & { scope?: Scope },\n    isTargetType: (...args: any) => boolean,\n    scope: Array<string>\n  ): ScopedStatement[] {\n    const matches: ScopedStatement[] = [];\n    if (scope.length >= this.maxScopeDepth) {\n      return matches;\n    }\n    if (val && typeof val === \"object\") {\n      if (!Array.isArray(val)) {\n        val.scope = scope;\n      }\n      if (isTargetType(val)) {\n        // @ts-ignore See `val` parameter\n        matches.push(val);\n      }\n\n      let currentScope = [...scope];\n      const nearestIdentifier: undefined | Identifier = Object.values(val).find(\n        (v) => v?.type === \"Identifier\"\n      );\n      if (nearestIdentifier) {\n        currentScope.push(nearestIdentifier.name);\n      }\n\n      for (const v of Object.values(val)) {\n        const mat = this._recurse(v, isTargetType, currentScope);\n        const toPush = mat?.filter(Boolean).flat();\n        if (toPush?.length) {\n          matches.push(...toPush.flat());\n        }\n      }\n    }\n\n    // @ts-ignore See `val` parameter\n    return matches;\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "BF19F44870454A0564756e2164756e21",
  "names": []
}