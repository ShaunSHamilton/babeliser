import{parse as L} from"@babel/parser";import M from"@babel/generator";import{is as C} from"@babel/types";class O{parsedCode;maxScopeDepth=4;codeString;constructor(w,A){if(this.parsedCode=L(w,{sourceType:"module",...A}),A?.maxScopeDepth)this.maxScopeDepth=A.maxScopeDepth;this.codeString=w}getArrowFunctionExpressions(){return this._recurseBodiesForType("ArrowFunctionExpression")}getExpressionStatements(){return this._recurseBodiesForType("ExpressionStatement")}getFunctionDeclarations(){return this._recurseBodiesForType("FunctionDeclaration")}getImportDeclarations(){return this._recurseBodiesForType("ImportDeclaration")}getType(w){return this._recurseBodiesForType(w)}getVariableDeclarations(){return this._recurseBodiesForType("VariableDeclaration")}getExpressionStatement(w,A=["global"]){return this.getExpressionStatements().filter((q)=>this._isInScope(q.scope,A)).find((q)=>{const k=q.expression;if(C("CallExpression",k)){if(w.includes(".")){const[F,G]=w.split("."),H=k.callee;if(C("MemberExpression",H)){const{object:J,property:K}=H;if(C("Identifier",J)&&C("Identifier",K))return J.name===F&&K.name===G}}const z=k.callee;if(C("Identifier",z)&&z.name===w)return!0}if(C("AwaitExpression",k)){const z=k.argument;if(C("CallExpression",z)){const F=z.callee;if(C("Identifier",F))return F.name===w}}return!1})}generateCode(w,A){return M(w,A).code}getLineAndColumnFromIndex(w){const A=this.codeString.slice(0,w).split("\n"),D=A.length,_=A.pop()?.length;return{line:D,column:_}}_isInScope(w,A=["global"]){if(A.length===1&&A[0]==="global")return!0;if(w.length<A.length)return!1;const D=w.join("."),_=A.join(".");return D.includes(_)}_recurseBodiesForType(w){const A=this.parsedCode.program.body,D=[];for(let _ of A){const q=this._recurse(_,(k)=>k?.type===w,["global"]);if(q?.length)D.push(...q)}return D}_recurse(w,A,D){const _=[];if(D.length>=this.maxScopeDepth)return _;if(w&&typeof w==="object"){if(!Array.isArray(w))w.scope=D;if(A(w))_.push(w);let q=[...D];const k=Object.values(w).find((z)=>z?.type==="Identifier");if(k)q.push(k.name);for(let z of Object.values(w)){const G=this._recurse(z,A,q)?.filter(Boolean).flat();if(G?.length)_.push(...G.flat())}}return _}}export{O as Babeliser};

//# debugId=BF19F44870454A0564756e2164756e21
